#!/usr/bin/python

# (c) Fry-IT Ltd
# Peter Bengtsson, peter@fry-it.com
# License: ZPL

"""click on the Refresh product button multiple times"""

usage="""
python click_on_product_refresh.py -u username:password [-r clever|forced] [-p /path/to/zope/lib/python] [http://ford.fry-it.com:9080/Control_Panel/Products/OCHProduct] [Products/IssueTrackerProduct]
"""

__version__='2.3.0'



from pprint import pprint
import sys, getopt, os, string, time
import types

try:
    from inotify import Inotify
    _has_inotify = True
    
except ImportError:
    import warnings
    #warnings.warn("inotify not installed. See http://susku.pyhaselka.fi/damu/software/")
    _has_inotify = False

import mtimer
    
COLOUR_OUT = True

ServerError=''
verbose=0
old=0
doctor=0
index_html=0

def wrap_out(s, colour=None):
    colours={"default":"",
             "blue":    chr(27) + "[01;34m",
             "cyan":   chr(27) + "[01;36m",
             "green":  chr(27) + "[01;32m",
             "red":    chr(27) + "[01;31m" }
    if COLOUR_OUT and sys.platform != 'win32' and colours.has_key(colour):
        return colours[colour] + str(s) + chr(27) + "[00m"
    return s

def log(s):
    f=open('.refresh.log','a')
    f.write('%s\n' % s)
    f.close()
                                    

def main():
    user, password = 'superuser', '123'
    opts, args = getopt.getopt(sys.argv[1:], 'p:u:r:DIv9')
    global verbose
    global old
    global doctor
    global index_html
    refresh_type = 'forced'
    havepath=None
    for o, v in opts:
        if o=='-p':
            d, f = os.path.split(v)
            if f=='ZPublisher': sys.path.insert(0,d)
            else: sys.path.insert(0,v)
            havepath=1
        elif o=='-u':
            v = string.split(v,':')
            user, password = v[0], string.join(v[1:],':')
        elif o=='-r':
            if v in ('forced','clever'):
                refresh_type = v 
        elif o=='-D': doctor=1
        elif o=='-I': index_html=1
        elif o=='-v': verbose=1
        elif o=='-9': old=1

    if not args:
        print sys.argv[0]+usage
        sys.exit(1)

    if not havepath:
        here=os.path.split(sys.argv[0])[0]
        if os.path.exists(os.path.join(here,'ZPublisher')):
            sys.path.insert(0,here)
        else:
            here=os.path.split(here)[0]
            here=os.path.join(here,'lib','python')
            if os.path.exists(os.path.join(here,'ZPublisher')):
                sys.path.insert(0,here)


    url=args[0]
    if not url.startswith('http'):
        url = 'http://localhost:8080/Control_Panel/Products/'+url

        
    local_product_folder=args[1]
    
    start(url, user, password, local_product_folder, refresh_type=refresh_type)


def _recursiveAddWatch(notifier, start_folder, mask):
    notifier.add_watch(start_folder, mask)
    folders = [x for x 
                 in os.listdir(start_folder) 
                 if os.path.isdir(os.path.join(start_folder, x))]
    folders = [os.path.join(start_folder, x) for x
                 in folders
                 if x not in ('CVS','.svn','tests','.autogenerated')]
    for sub_folder in folders:
        _recursiveAddWatch(notifier, sub_folder, mask)
    
    
def start_multiple(products, user, password, refresh_type='forced', 
                   run_once=False,
                   mtimer_options={}):
    """ similar to start() but using multiple configurations """
    import ZPublisher.Client
    from Globals import DevelopmentMode
    global ServerError
    ServerError=ZPublisher.Client.ServerError
    #objects=[ZPublisher.Client.Object(url, username=user, password=password)]
    
    products_by_path = {}
    for product in products:
        key = product['productpath']
        url = product['CTurl']
        
        dependencies = product.get('dependencies',None)
        if isinstance(dependencies, basestring):
            dependencies = [dependencies]
        elif isinstance(dependencies, tuple):
            dependencies = list(dependencies)
            
        if dependencies:
            #
            # this dependency list is expected to be a list of urls
            # that start like the 'url' variable does. If that's not the case,
            # fix them. 
            baseurl = '/'.join(url.split('/')[:-1])
            for i in range(len(dependencies)):
                if not dependencies[i].startswith(baseurl):
                    dependencies[i] = baseurl + '/' + dependencies[i]

        if url.endswith('/'):
            url = url[:-1]
        products_by_path[key] = product
        objects = [ZPublisher.Client.Object(url, username=user, password=password)]
        products_by_path[key]['pre_run_command'] = product.get('pre_run_command')
        products_by_path[key]['post_run_command'] = product.get('post_run_command')
        if dependencies:
            for dep_url in dependencies:
                objects.append(ZPublisher.Client.Object(dep_url, username=user, password=password))
                
        #products_by_path[key]['dependencies'] = dependencies # cleaned up
        products_by_path[key]['objects'] = objects
        
        
    if _has_inotify:
        extensions_to_scan = ('sql','py','zpt','dtml','pt','js')
        
    if refresh_type == 'clever' and DevelopmentMode:
        # cool, then we don't have refresh when there's a change to 
        # templates like .dtml and .zpt
        if _has_inotify:
            extensions_to_scan = ('sql','py','js','css')
        else:
            mtimer.EXTENSIONS_TO_SCAN = ('sql','py','css','js')
            mtimer.FOLDERS_TO_SKIP = ('tests', '.autogenerated', 'zpt','dtml') + mtimer.FOLDERS_TO_SKIP
    else:
        mtimer.FOLDERS_TO_SKIP = ('tests', '.autogenerated') + mtimer.FOLDERS_TO_SKIP
        
    c = 0
    
    if _has_inotify and not run_once:
        notifier = Inotify()
        mask = Inotify.IN_MODIFY
        for product_path, config in products_by_path.items():
            assert os.path.isdir(product_path), \
            "product path does not exist %s" % product_path
            _recursiveAddWatch(notifier, product_path, mask)
            
        while 1:
            events = notifier.read_events()
            for event in events:
                event_string = notifier.event_string(event[Inotify.MASK])
                path_wid = notifier.file(event[Inotify.WID])
                file_wid = event[Inotify.FILE]
                file_wid_extension = file_wid.split('.')[-1]
                if file_wid_extension in extensions_to_scan:
                    # the path might be 'Products/Foo/zpt/widgets' when the product 
                    # path is just 'Products/Foo'
                    for product_path, config in products_by_path.items():
                        if path_wid.startswith(product_path):
                            _file_path = os.path.join(path_wid, file_wid).replace('Products/','')
                            print _file_path,
                            t0 = time.time()
                            r = refresh_product(config['objects'], config['pre_run_command'], config['post_run_command'])
                            t1 = time.time()
                            log("%s:%s:%s" % (_file_path, t1-t0, time.time()))
                            if r:
                                print r
                            else:
                                print "done"
                            #print event_string
                            break
        
    else:
        
        def _getSleeptime():
            try:
                return float(open('sleeptime.conf').read().split()[0])
            except:
                return 4.0 # seconds

        def _saveSleeptime(sleeptime):
            open('sleeptime.conf','w').write(str(sleeptime))
            
        delta = 0.0
        product_info = {}
        while 1:
            try:
                sleeptime = _getSleeptime()
                for product_path, config in products_by_path.items():
                    #t0=time.time()
                    difference, info = mtimer.run(product_path, prev_info=product_info.get(product_path, None),
                                                  **mtimer_options)
                    product_info[product_path] = info
                    if difference == 'Different':
                        t0 = time.time()
                        refresh_product(config['objects'], config['pre_run_command'], config['post_run_command']),
                        t1 = time.time()
                        print "(%s)" % (seconds2time(c))
                        log("%s:%s:%s" % (product_path, t1-t0, time.time()))
                        delta = 0.0
                    #print time.time()-t0, "in", product_path
                
                if run_once:
                    break
    
                #print "Sleep(%s)" % sleeptime
                time.sleep(sleeptime + delta) #; print "sleep", sleeptime + delta
                
                # every time there's. For every loop, increase the sleeptime with
                # a tiny delta that can't be bigger than the sleeptime.
                # this min() makes sure the extra time never exceeds the original
                # sleeptime. This means that if you leave this running for a very
                # long time the (sleeptime+delta) === sleeptime*2
                delta = min(delta + sleeptime/200.0, sleeptime)
                
                c += sleeptime
            except KeyboardInterrupt:
                break
        

def start(url, user, password, local_product_folder, refresh_type='forced',
          dependencies=[],
          run_once=False):
    import warnings
    warnings.warn('This is dying. Use start_multiple() instead', DeprecationWarning)
    
    import ZPublisher.Client
    global ServerError
    ServerError=ZPublisher.Client.ServerError
    objects=[ZPublisher.Client.Object(url, username=user, password=password)]
    
    from Globals import DevelopmentMode
    
    if url.endswith('/'):
        url = url[:-1]
    
    if isinstance(dependencies, basestring):
        dependencies = [dependencies]
        
    #if dependency:
    #    dependencies.append(dependency)
        
    #
    # this dependency list is expected to be a list of urls
    # that start like the 'url' variable does. If that's not the case,
    # fix them. 
    baseurl = '/'.join(url.split('/')[:-1])
    for i in range(len(dependencies)):
        if not dependencies[i].startswith(baseurl):
            dependencies[i] = baseurl + '/' + dependencies[i]
            
    for dep_url in dependencies:
        objects.append(ZPublisher.Client.Object(dep_url, username=user, password=password))
    
    if refresh_type == 'clever' and DevelopmentMode:
        # cool, then we don't have refresh when there's a change to 
        # templates like .dtml and .zpt
        mtimer.EXTENSIONS_TO_SCAN = ('sql','py')
        
    
    c = 0
    while 1:
        try:
            sleeptime = int(open('sleeptime.conf').read())
        except:
            sleeptime = 5
        
        if mtimer.run(local_product_folder)=='Different':
            print refresh_product(objects),
            print "(%s)" % (seconds2time(c))
            
        if run_once:
            break

        time.sleep(sleeptime)
        open('sleeptime.conf','w').write(str(sleeptime))
        c += sleeptime

def seconds2time(seconds):
    minutes = int(seconds)/60
    hours = int(minutes)/60
    seconds = seconds%60
    minutes = minutes%60
    out = []
    if hours:
        if hours ==1:
            out.append("1 hour")
        else:
            out.append("%s hours"%hours)
    if minutes:
        if minutes ==1:
            out.append("1 minute")
        else:
            out.append("%s minutes"%minutes)
    if seconds:
        if seconds==1:
            out.append("1 second")
        else:
            out.append("%s seconds"%seconds)
            
    return " ".join(out)

        
        
def _renderHTTPOutRefreshMessage(out):
    pos = out.find('<b>Important information about refreshing this product:</b>')
    if pos > -1:
        out = out[pos:]
        out = out[out.find('<p>')+len('<p>'):]
        out = out[:out.find('</p>')]
        return wrap_out(out, colour='green')
    
    pos = out.find('<b>An exception occurred during the last refresh.</b>')
    if pos > -1:
        out = out[pos:]
        out = out[:out.find('</pre>')]
        out = out.replace('<b>','**').replace('</b>','**')
        out = out.replace('<br />','').replace('<br>','')
        out = out.replace('</p>','').replace('<pre>','')
        lastline = out.strip().split('\n')[-1]
        head = "<!"+"-"*77+">"
        foot = "<"+"-"*(78-len(lastline)-5)+" "+lastline+ " --->"

        out = "%s\n%s\n%s"%(head, out, foot)
        return wrap_out(out, colour='red')
    
    return ""
        
def refresh_product(objects, pre_run_command=None, post_run_command=None):
    
    if pre_run_command:
        os.system(pre_run_command)
        
    msgs = [_refresh_product(o) for o in objects]
    
    if post_run_command:
        os.system(post_run_command)
        
    return "\n".join([x.strip() for x in msgs if x.strip()])

def _refresh_product(object):
    
    result = call(object.manage_performRefresh)
    if len(result)==2:
        http_mesg, http_out = result
        little_mesg = _renderHTTPOutRefreshMessage(http_out)
        return little_mesg
    else:
        #print result
        return ""    
    
        

def call(f, *args, **kw):
    # Call a function ignoring redirect bci errors.
    #return apply(f, args, kw)
    try: return apply(f,args, kw)
    except ServerError, v:
        if str(v)[:1] != '3':
            #raise "Anything", "else"
            raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]

def upload_file(object, f):
    if os.path.isdir(f): return upload_dir(object, f)
    dir, name = os.path.split(f)
    root, ext = os.path.splitext(name)
    if ext in ('file', 'dir'): ext=''
    else:
        ext=string.lower(ext)
        if ext and ext[0] in '.': ext=ext[1:]
    if ext and globals().has_key('upload_'+ext):
        if verbose: print 'upload_'+ext, f
        return globals()['upload_'+ext](object, f)

    if verbose: print 'upload_file', f, ext
    call(object.manage_addFile, id=name, file=open(f,'rb'))

def upload_dir(object, f):
    if verbose: print 'upload_dir', f
    dir, name = os.path.split(f)
    call(object.manage_addFolder, id=name)
    object=object.__class__(object.url+'/'+name,
                            username=object.username,
                            password=object.password)
    for n in os.listdir(f):
        upload_file(object, os.path.join(f,n))

# ----- phd -----
# Modified by Oleg Broytmann <phd2@earthling.net>

from sgmllib import SGMLParser

def join_attrs(attrs):
    attr_list = []
    for attrname, value in attrs:
        attr_list.append('%s="%s"' % (attrname, string.strip(value)))

    if attr_list:
        s = " " + string.join(attr_list, " ")
    else:
        s = ""

    return s


class HeadParser(SGMLParser):
    def __init__(self):
        SGMLParser.__init__(self)

        self.seen_starthead = 0
        self.seen_endhead   = 0
        self.seen_startbody = 0

        self.head = ""
        self.title = ""
        self.accumulator = ""


    def handle_data(self, data):
        if data:
            self.accumulator = self.accumulator + data

    def handle_charref(self, ref):
        self.handle_data("&#%s;" % ref)

    def handle_entityref(self, ref):
        self.handle_data("&%s;" % ref)

    def handle_comment(self, data):
        if data:
            self.accumulator = self.accumulator + "<!--%s-->" % data


    def start_head(self, attrs):
        if not self.seen_starthead:
            self.seen_starthead = 1
            self.head = ""
            self.title = ""
            self.accumulator = ""

    def end_head(self):
        if not self.seen_endhead:
            self.seen_endhead = 1
            self.head = self.head + self.accumulator
            self.accumulator = ""


    def start_title(self, attrs):
        self.head = self.head + self.accumulator
        self.accumulator = ""

    def end_title(self):
        self.title = self.accumulator
        self.accumulator = ""


    def start_body(self, attrs):
        if not self.seen_startbody:
            self.seen_startbody = 1
            self.accumulator = ""

    def end_body(self): pass # Do not put </BODY> and </HTML>
    def end_html(self): pass # into output stream


    # Pass other tags unmodified
    def unknown_starttag(self, tag, attrs):
        self.accumulator = self.accumulator + "<%s%s>" % (string.upper(tag), join_attrs(attrs))

    def unknown_endtag(self, tag):
        self.accumulator = self.accumulator + "</%s>" % string.upper(tag)



def parse_html(infile):
    parser = HeadParser()

    while 1:
        line = infile.readline()
        if not line: break
        parser.feed(line)

    parser.close()
    infile.close()

    return (string.strip(parser.title), string.strip(parser.head),
            string.strip(parser.accumulator))


# ----- /phd -----


"""
getpass - password aquisition
getuser - login name aquisition

Taken from http://www.cs.usyd.edu.au/~piers/python/py2html.cgi/~piers/python/getpass
"""


def getpass(prompt = 'Password'):
    """ password = getpass(prompt = 'Password')
    
    Get a password with echo turned off
    - restore terminal settings at end.
    """


    if not sys.stdin.isatty():
        passwd = sys.stdin.read()
        while len(passwd) > 0 and passwd[-1] in ('\r', '\n'):
            passwd = passwd[:-1]
        return passwd

    import termios
    if not hasattr(termios, 'ECHO'):
        import TERMIOS                # Old module for termios constants
    else:
        TERMIOS = termios        # Now included

    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)        # a copy to save
    new = old[:]                        # a copy to modify

    new[3] = new[3] & ~TERMIOS.ECHO        # 3 == 'lflags'
    try:
        termios.tcsetattr(fd, TERMIOS.TCSADRAIN, new)
        try: passwd = raw_input(prompt+': ')
        except (KeyboardInterrupt, EOFError): passwd = None
    finally:
        termios.tcsetattr(fd, TERMIOS.TCSADRAIN, old)

    sys.stdout.write('\n')
    sys.stdout.flush()
    return passwd


def getuser():
    """ login = getuser()
    
    Return invoker's login id.
    """

    for name in ('LOGNAME', 'USER', 'LNAME'):
        if os.environ.has_key(name):
            # assert ourselfs
            default = os.environ[name]
            right = raw_input("Username [%s]: "%default)
            if not right:
                right = default
            return right

    try:
        import pwd
    except ImportError:
        manual_username = raw_input("Username [%s]: "%default)
        return manual_username

    try:
        return pwd.getpwuid(os.getuid())[0]
    except:
        raise 'Who are you?'

    
_opid = os.path.isdir
_opj = os.path.join
def _findLibPath():
    from glob import glob
    """ if you're lazy we'll have to find zope's python
    lib path ourselfs """
    if _opid(_opj(os.path.abspath('.'), 'lib','python')):
        return _opj(os.path.abspath('.'), 'lib','python')
    elif glob('/usr/lib/zope*/lib/python'):
        findings = glob('/usr/lib/zope*/lib/python')
        if len(findings) > 1:
            findings.sort() # makes lowest first
            return findings[-1]
        else:
            return findings[0]
        
    return None # default
        
        
        
    
def cli(*args, **kwds):
    """ handle the starting of start() by parsing and setting up all 
    the config here in this function. """
    if len(args)==1 and isinstance(args[0], dict):
        # it was called as cli(globals()) probably
        _kws_ = args[0]
        args = list(args)
        kwds.update(_kws_)
        args.remove(_kws_)
        args = tuple(args)
        
    netrc_authenticator = kwds.get('netrc_authenticator','')
    refresh_type = kwds.get('refresh_type','')
    mtimer_options = kwds.get('mtimer_options', {})
    libpath = kwds.get('libpath')
    if not libpath:
        libpath = _findLibPath()
        if not libpath:
            #raise "NoLibPath", "Set where your Zope's lib/python path is"
            libpath = None
        
    if kwds.get('products'):
        products = tuple(kwds['products'])
    else:
        # there is only one product to monitor for changes
        product = dict(CTurl=kwds['CTurl'],
                       productpath=kwds['productpath'],
                       dependencies=kwds.get('dependencies',None)
                       )
        products = (product,)
    
            
    # Now do the usual cli stuff before we can start
    import os, netrc, sys
    # start the refresihing
    ask_for_password = 1
    try:
        credentials = netrc.netrc()
        ret = credentials.authenticators(netrc_authenticator)
        if ret:
            uname, account, passw = ret
            ask_for_password = 0
    except IOError, e:
        print >>sys.stderr, "missing .netrc file %s" %  str(e).split()[-1]

    if ask_for_password:    
        uname = getuser()
        passw = getpass()
    
    if libpath and not os.path.abspath(libpath) in sys.path:
        sys.path.insert(0, libpath)
        
    args = sys.argv[1:]
    
    run_once = 0
    if 'once' in args:
        run_once = 1
        args.remove('once')
    elif '--once' in args:
        run_once = 1
        args.remove('--once')

    only_products = []
    _productnames = [x['productpath'].split('/')[-1] for x in products]
    for arg in args:
        for p in products:
            if p['productpath'].split('/')[-1] == arg:
                only_products.append(p)
            elif arg in p.get('dependencies', []):
                only_products.append(p)

    if [x for x in args if not x.startswith('-')] and not only_products:
        raise SystemError, "No product called %r" % args[0]
        
    if only_products:
        # of those in there, remove the dependencies on those 
        # not the new list of productnames
        products = only_products
        _productnames = [x['productpath'].split('/')[-1] for x in products]
        for i, p in enumerate(products):
            if p.get('dependencies'):
                new_dependencies = _intersection(_productnames, p.get('dependencies'))
                p['dependencies'] = new_dependencies
                

    if '--help' in args or '-h' in args:
        print "USAGE: python %s [product name*]" % (__file__.replace(os.path.abspath(os.curdir), '.'))
        print ""
        print "* Available product names:"
        for p in _productnames:
            print "\t%s" % p
            
        sys.exit(1)
        
    print "Monitoring..."
    for e in products:
        print "\t", e['productpath']
        
        
    start_multiple(products, uname, passw, refresh_type=refresh_type,
                   run_once=run_once,
                   mtimer_options=mtimer_options)

def _intersection(lista, listb):
    from sets import Set
    return list(Set(lista) & Set(listb))

if __name__=='__main__': main()

